# utils/binance_api/bi_advanced_validator.py
"""
# Geli≈ümi≈ü versiyon
python utils/binance_api/bit_advanced_validator.py


‚úÖ Otomatik YAML parsing - Manuel liste gerekmez
‚úÖ Smart parameter selection - Endpoint tipine g√∂re parametre
‚úÖ Async testing - Hƒ±zlƒ± sonu√ß
‚úÖ Detailed reporting - Gruplandƒ±rƒ±lmƒ±≈ü sonu√ßlar
‚úÖ Error handling - Timeout ve hata y√∂netimi
‚úÖ Section grouping - Public/private ayrƒ±mƒ±

public + 
"""
# utils/binance_api/bi_advanced_validator.py
import requests
import yaml
import asyncio
import aiohttp
from typing import Dict, List, Any
import os
import json
from pathlib import Path

class BinanceEndpointValidator:
    def __init__(self):
        self.base_urls = {
            "spot": "https://api.binance.com",
            "futures": "https://fapi.binance.com"
        }
        self.results = []
        self.corrections_needed = []
        
        # Doƒüru path mapping'i
        self.correct_paths = {
            # Futures data endpoints
            "/fapi/v1/globalLongShortAccountRatio": "/futures/data/globalLongShortAccountRatio",
            "/fapi/v1/topLongShortAccountRatio": "/futures/data/topLongShortAccountRatio", 
            "/fapi/v1/topLongShortPositionRatio": "/futures/data/topLongShortPositionRatio",
            "/fapi/v1/takerlongshortRatio": "/futures/data/takerlongshortRatio",
            "/fapi/v1/openInterestHist": "/futures/data/openInterestHist",
            "/fapi/v1/takerBuySellVol": "/futures/data/takerBuySellVol",
            
            # Diƒüer d√ºzeltmeler
            "/fapi/v1/openInterest": "/fapi/v1/openInterest",  # Bu doƒüru, parametre sorunu
            "/fapi/v1/allForceOrders": "/fapi/v1/allForceOrders",  # Bu doƒüru, parametre sorunu
            "/fapi/v1/adlQuantile": "/fapi/v1/adlQuantile",  # Bu doƒüru, parametre sorunu
            "/fapi/v1/historicalTrades": "/fapi/v1/historicalTrades"  # Bu doƒüru, parametre sorunu
        }
    
    def load_yaml_endpoints(self, file_path: str) -> Dict[str, Any]:
        """YAML dosyasƒ±ndan endpoint'leri y√ºkle"""
        with open(file_path, 'r', encoding='utf-8') as f:
            return yaml.safe_load(f)
    
    def extract_testable_endpoints(self, yaml_data: Dict[str, Any], file_path: str) -> List[Dict]:
        """YAML'den test edilebilir endpoint'leri √ßƒ±kar"""
        endpoints = []
        
        for section_name, section_data in yaml_data.items():
            if section_name == "meta":
                continue
                
            if isinstance(section_data, dict):
                for endpoint_name, endpoint_info in section_data.items():
                    # Sadece public ve GET endpoint'leri test et
                    if (endpoint_info.get('signed', True) == False and 
                        endpoint_info.get('http_method') == 'GET' and
                        endpoint_info.get('enabled', True)):
                        
                        endpoints.append({
                            'name': endpoint_name,
                            'path': endpoint_info['path'],
                            'base': endpoint_info.get('base', 'spot'),
                            'section': section_name,
                            'file': os.path.basename(file_path),
                            'full_info': endpoint_info  # Tam bilgiyi sakla
                        })
        
        return endpoints
    

    async def test_endpoint_async(self, endpoint: Dict, session: aiohttp.ClientSession):
        """Async endpoint testi"""
        base_url = self.base_urls[endpoint['base']]
        current_path = endpoint['path']
        corrected_path = self.correct_paths.get(current_path, current_path)
        needs_correction = current_path != corrected_path
        
        url = f"{base_url}{current_path}"
        params = self._get_test_params(current_path)
        
        try:
            async with session.get(url, params=params, timeout=aiohttp.ClientTimeout(total=10)) as response:
                response_text = await response.text()  # ‚úÖ Response text'ini al
                status = response.status
                
                # ‚úÖ YENƒ∞: KALDIRILMI≈û ENDPOINT KONTROL√ú
                if status == 400 and "out of maintenance" in response_text:
                    return {
                        'endpoint': endpoint['name'],
                        'current_path': current_path,
                        'corrected_path': corrected_path,
                        'status': '‚ùå KALDIRILMI≈û',
                        'status_code': status,
                        'base': endpoint['base'],
                        'section': endpoint['section'],
                        'file': endpoint['file'],
                        'needs_correction': needs_correction,
                        'note': 'Binance bu endpointi kaldƒ±rdƒ±'
                    }
                
                if status == 200:
                    result = {
                        'endpoint': endpoint['name'],
                        'current_path': current_path,
                        'corrected_path': corrected_path,
                        'status': '‚úÖ BA≈ûARILI',
                        'status_code': status,
                        'base': endpoint['base'],
                        'section': endpoint['section'],
                        'file': endpoint['file'],
                        'needs_correction': needs_correction,
                        'test_url': f"{base_url}{current_path}",
                        'params_used': params
                    }
                    
                    if needs_correction:
                        self.corrections_needed.append(result)
                    
                    return result
                else:

                    # Hata durumunda d√ºzeltilmi≈ü path'i test et
                    if needs_correction:
                        corrected_url = f"{base_url}{corrected_path}"
                        try:
                            async with session.get(corrected_url, params=params, timeout=aiohttp.ClientTimeout(total=10)) as corrected_response:
                                if corrected_response.status == 200:
                                    result = {
                                        'endpoint': endpoint['name'],
                                        'current_path': current_path,
                                        'corrected_path': corrected_path,
                                        'status': 'üîÑ D√úZELTƒ∞LEBƒ∞Lƒ∞R',
                                        'status_code': corrected_response.status,
                                        'base': endpoint['base'],
                                        'section': endpoint['section'],
                                        'file': endpoint['file'],
                                        'needs_correction': True,
                                        'test_url': corrected_url,
                                        'params_used': params,
                                        'note': 'D√úZELTƒ∞LMƒ∞≈û PATH √áALI≈ûIYOR'
                                    }
                                    self.corrections_needed.append(result)
                                    return result
                        except:
                            pass
                    
                    return {
                        'endpoint': endpoint['name'],
                        'current_path': current_path,
                        'corrected_path': corrected_path,
                        'status': '‚ùå HATALI',
                        'status_code': status,
                        'base': endpoint['base'],
                        'section': endpoint['section'],
                        'file': endpoint['file'],
                        'needs_correction': needs_correction,
                        'test_url': url,
                        'params_used': params,
                        'error': f"HTTP {status}"
                    }
        except asyncio.TimeoutError:
            return {
                'endpoint': endpoint['name'],
                'current_path': current_path,
                'corrected_path': corrected_path,
                'status': '‚è∞ TIMEOUT',
                'status_code': 0,
                'base': endpoint['base'],
                'section': endpoint['section'],
                'file': endpoint['file'],
                'needs_correction': needs_correction
            }
        except Exception as e:
            return {
                'endpoint': endpoint['name'],
                'current_path': current_path,
                'corrected_path': corrected_path,
                'status': 'üí• HATA',
                'status_code': 0,
                'base': endpoint['base'],
                'section': endpoint['section'],
                'file': endpoint['file'],
                'needs_correction': needs_correction,
                'error': str(e)
            }
    
    def _get_test_params(self, path: str) -> Dict[str, str]:
        """Endpoint'e g√∂re test parametreleri olu≈ütur"""
        params = {}
        
        # Spot endpoints
        if 'ticker' in path or 'price' in path:
            params['symbol'] = 'BTCUSDT'
        elif 'klines' in path:
            params['symbol'] = 'BTCUSDT'
            params['interval'] = '1m'
            params['limit'] = '1'
        elif 'depth' in path:
            params['symbol'] = 'BTCUSDT'
            params['limit'] = '5'
        elif 'trades' in path:
            params['symbol'] = 'BTCUSDT'
            params['limit'] = '1'
        elif 'exchangeInfo' in path:
            pass
        elif 'avgPrice' in path:
            params['symbol'] = 'BTCUSDT'
        elif 'historicalTrades' in path:
            params['symbol'] = 'BTCUSDT'
            params['limit'] = '1'
        
        # Futures data endpoints
        elif 'globalLongShortAccountRatio' in path:
            params['symbol'] = 'BTCUSDT'
            params['period'] = '5m'
            params['limit'] = '1'
        elif 'topLongShortAccountRatio' in path:
            params['symbol'] = 'BTCUSDT'
            params['period'] = '5m'
            params['limit'] = '1'
        elif 'topLongShortPositionRatio' in path:
            params['symbol'] = 'BTCUSDT'
            params['period'] = '5m'
            params['limit'] = '1'
        elif 'takerlongshortRatio' in path:
            params['symbol'] = 'BTCUSDT'
            params['period'] = '5m'
            params['limit'] = '1'
        elif 'openInterestHist' in path:
            params['symbol'] = 'BTCUSDT'
            params['period'] = '5m'
            params['limit'] = '1'
        elif 'takerBuySellVol' in path:
            params['symbol'] = 'BTCUSDT'
            params['period'] = '5m'
            params['limit'] = '1'
        
        # Futures API endpoints
        elif 'allForceOrders' in path:
            params['symbol'] = 'BTCUSDT'
            params['limit'] = '1'
        elif 'adlQuantile' in path:
            params['symbol'] = 'BTCUSDT'
        elif 'openInterest' in path:
            params['symbol'] = 'BTCUSDT'
        
        # YENƒ∞ EKLENEN PARAMETRELER:
        elif 'continuousKlines' in path:
            params['pair'] = 'BTCUSDT'
            params['contractType'] = 'PERPETUAL' 
            params['interval'] = '1m'
            params['limit'] = '1'
        elif 'indexPriceKlines' in path:
            params['pair'] = 'BTCUSDT'
            params['interval'] = '1m'
            params['limit'] = '1'
        elif 'markPriceKlines' in path:
            params['symbol'] = 'BTCUSDT'
            params['interval'] = '1m'
            params['limit'] = '1'
        elif 'aggTrades' in path:
            params['symbol'] = 'BTCUSDT'
            params['limit'] = '1'
        elif 'allForceOrders' in path:
            params['symbol'] = 'BTCUSDT'
            params['limit'] = '1'
        elif 'takerlongshortRatio' in path:  # D√úZELTƒ∞LDƒ∞
            params['symbol'] = 'BTCUSDT'
            params['period'] = '5m'
            params['limit'] = '10'
        
        elif 'allForceOrders' in path:
            params['symbol'] = 'BTCUSDT'
            params['limit'] = '1'
            # ƒ∞steƒüe baƒülƒ±: params['startTime'] = str(int(time.time() * 1000) - 3600000)  # 1 saat √∂nce
            
            
            
        return params
        
        

    
    async def validate_yaml_files(self, yaml_files: List[str]):
        """T√ºm YAML dosyalarƒ±nƒ± validate et"""
        print("üîç Binance Endpoint Validator Ba≈ülatƒ±lƒ±yor...\n")
        
        all_endpoints = []
        
        # T√ºm YAML dosyalarƒ±ndan endpoint'leri topla
        for yaml_file in yaml_files:
            try:
                if not os.path.exists(yaml_file):
                    print(f"‚ùå {yaml_file} dosyasƒ± bulunamadƒ±!")
                    continue
                    
                data = self.load_yaml_endpoints(yaml_file)
                endpoints = self.extract_testable_endpoints(data, yaml_file)
                all_endpoints.extend(endpoints)
                print(f"üìÅ {yaml_file}: {len(endpoints)} endpoint bulundu")
            except Exception as e:
                print(f"‚ùå {yaml_file} y√ºklenirken hata: {e}")
        
        print(f"\nüéØ Toplam {len(all_endpoints)} endpoint test edilecek...\n")
        
        if not all_endpoints:
            print("‚ö†Ô∏è  Test edilecek endpoint bulunamadƒ±!")
            return
        
        # Async testleri ba≈ülat
        async with aiohttp.ClientSession() as session:
            tasks = []
            for endpoint in all_endpoints:
                task = self.test_endpoint_async(endpoint, session)
                tasks.append(task)
            
            results = await asyncio.gather(*tasks)
            
            # Sonu√ßlarƒ± g√∂ster
            self.display_detailed_results(results)
    
    def display_detailed_results(self, results: List[Dict]):
        """Detaylƒ± sonu√ßlarƒ± g√∂ster"""
        successful = [r for r in results if '‚úÖ' in r['status']]
        correctable = [r for r in results if 'üîÑ' in r['status']]
        failed = [r for r in results if '‚ùå' in r['status'] or 'üí•' in r['status'] or '‚è∞' in r['status']]
        
        print("\n" + "="*80)
        print("üéØ DETAYLI VALIDATION SONU√áLARI")
        print("="*80)
        
        print(f"‚úÖ BA≈ûARILI: {len(successful)}")
        print(f"üîÑ D√úZELTƒ∞LEBƒ∞Lƒ∞R: {len(correctable)}") 
        print(f"‚ùå HATALI: {len(failed)}")
        print(f"üìù TOPLAM D√úZELTME GEREKEN: {len(self.corrections_needed)}")
        
        # D√úZELTƒ∞LEBƒ∞Lƒ∞R endpoint'leri g√∂ster
        if correctable:
            print(f"\nüü° D√úZELTƒ∞LEBƒ∞Lƒ∞R ENDPOINT'LER:")
            print("-" * 80)
            for result in correctable:
                print(f"üîÑ {result['endpoint']}")
                print(f"   ESKƒ∞ Path: {result['current_path']}")
                print(f"   YENƒ∞ Path: {result['corrected_path']}")
                print(f"   Section: {result['section']}")
                if 'note' in result:
                    print(f"   Not: {result['note']}")
                print()
        
        # HATALI endpoint'leri g√∂ster
        if failed:
            print(f"\nüî¥ HATALI ENDPOINT'LER:")
            print("-" * 80)
            for result in failed:
                print(f"{result['status']} {result['endpoint']}")
                print(f"   Path: {result['current_path']}")
                print(f"   File: {result['file']}")
                print(f"   Section: {result['section']}")
                if 'error' in result:
                    print(f"   Hata: {result['error']}")
                print()
        
        # BA≈ûARILI endpoint'leri g√∂ster (d√ºzeltme gerekenlerle birlikte)
        if successful:
            print(f"\nüü¢ BA≈ûARILI ENDPOINT'LER:")
            print("-" * 80)
            
            for result in successful:
                status_icon = "üîß" if result['needs_correction'] else "‚úÖ"
                print(f"{status_icon} {result['endpoint']}")
                print(f"   Path: {result['current_path']}")
                if result['needs_correction']:
                    print(f"   ‚ö†Ô∏è  D√úZELTME √ñNERƒ∞LEN: {result['corrected_path']}")
                print(f"   Section: {result['section']}")
                print()
        
        # D√ºzeltme √∂nerilerini JSON'a kaydet
        if self.corrections_needed:
            self.save_corrections_to_file()
    
    def save_corrections_to_file(self):
        """D√ºzeltme √∂nerilerini JSON dosyasƒ±na kaydet"""
        corrections_data = {
            'timestamp': time.time(),
            'total_corrections': len(self.corrections_needed),
            'corrections': self.corrections_needed
        }
        
        output_file = "binance_path_corrections.json"
        with open(output_file, 'w', encoding='utf-8') as f:
            json.dump(corrections_data, f, indent=2, ensure_ascii=False)
        
        print(f"\nüíæ D√ºzeltme √∂nerileri '{output_file}' dosyasƒ±na kaydedildi")
        
        # Otomatik d√ºzeltme se√ßeneƒüi sun
        self.offer_auto_correction()
    
    def offer_auto_correction(self):
        """Otomatik d√ºzeltme teklifi"""
        if not self.corrections_needed:
            return
        
        print(f"\nüîÑ OTOMATƒ∞K D√úZELTME ƒ∞≈ûLEMƒ∞")
        print("-" * 50)
        print(f"Toplam {len(self.corrections_needed)} endpoint d√ºzeltilecek.")
        
        response = input("YAML dosyalarƒ±nƒ± otomatik d√ºzeltmek istiyor musunuz? (e/h): ")
        if response.lower() in ['e', 'y', 'yes', 'evet']:
            self.apply_corrections()
        else:
            print("D√ºzeltme i≈ülemi iptal edildi.")
    
    def apply_corrections(self):
        """YAML dosyalarƒ±nƒ± otomatik d√ºzelt"""
        corrections_by_file = {}
        
        # D√ºzeltmeleri dosyaya g√∂re grupla
        for correction in self.corrections_needed:
            file_name = correction['file']
            if file_name not in corrections_by_file:
                corrections_by_file[file_name] = []
            corrections_by_file[file_name].append(correction)
        
        # Her dosyayƒ± d√ºzelt
        for file_name, corrections in corrections_by_file.items():
            file_path = f"utils/binance_api/{file_name}"
            
            if not os.path.exists(file_path):
                print(f"‚ùå {file_path} dosyasƒ± bulunamadƒ±!")
                continue
            
            try:
                # YAML dosyasƒ±nƒ± y√ºkle
                with open(file_path, 'r', encoding='utf-8') as f:
                    data = yaml.safe_load(f)
                
                # D√ºzeltmeleri uygula
                corrections_applied = 0
                for correction in corrections:
                    section = correction['section']
                    endpoint_name = correction['endpoint']
                    new_path = correction['corrected_path']
                    
                    if section in data and endpoint_name in data[section]:
                        old_path = data[section][endpoint_name]['path']
                        if old_path != new_path:
                            data[section][endpoint_name]['path'] = new_path
                            corrections_applied += 1
                            print(f"   üîÑ {endpoint_name}: {old_path} ‚Üí {new_path}")
                
                # D√ºzeltilmi≈ü dosyayƒ± kaydet
                if corrections_applied > 0:
                    with open(file_path, 'w', encoding='utf-8') as f:
                        yaml.dump(data, f, default_flow_style=False, allow_unicode=True, indent=2)
                    
                    print(f"‚úÖ {file_name}: {corrections_applied} d√ºzeltme uygulandƒ±")
                else:
                    print(f"‚ÑπÔ∏è  {file_name}: D√ºzeltme gerekmiyor")
                    
            except Exception as e:
                print(f"‚ùå {file_name} d√ºzeltilirken hata: {e}")

# Kullanƒ±m √∂rneƒüi
async def main():
    validator = BinanceEndpointValidator()
    
    # Test edilecek YAML dosyalarƒ±
    yaml_files = [
        "utils/binance_api/b-map_public.yaml",
        "utils/binance_api/b-map_private.yaml"
    ]
    
    await validator.validate_yaml_files(yaml_files)

if __name__ == "__main__":
    import time
    asyncio.run(main())